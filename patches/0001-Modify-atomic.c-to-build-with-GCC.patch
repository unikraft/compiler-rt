From 9aa315b7c38f03ab136157fb91f39569ae62dafc Mon Sep 17 00:00:00 2001
From: Delia-Maria Pavel <delia_maria.pavel@stud.acs.upb.ro>
Date: Wed, 14 Sep 2022 20:35:00 +0300
Subject: [PATCH] Modify atomic.c to build with GCC

Signed-off-by: Delia-Maria Pavel <delia_maria.pavel@stud.acs.upb.ro>
---
 lib/builtins/atomic.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/lib/builtins/atomic.c b/lib/builtins/atomic.c
index ee35e34..398b3a3 100644
--- a/lib/builtins/atomic.c
+++ b/lib/builtins/atomic.c
@@ -90,13 +90,24 @@ static Lock locks[SPINLOCK_COUNT]; // initialized to OS_SPINLOCK_INIT which is 0
 typedef _Atomic(uintptr_t) Lock;
 /// Unlock a lock.  This is a release operation.
 __inline static void unlock(Lock *l) {
+#ifdef __GNUC__
+  __atomic_store_n(l, 0, __ATOMIC_RELEASE);
+#endif
+#ifdef __clang__
   __c11_atomic_store(l, 0, __ATOMIC_RELEASE);
+#endif
 }
 /// Locks a lock.  In the current implementation, this is potentially
 /// unbounded in the contended case.
 __inline static void lock(Lock *l) {
   uintptr_t old = 0;
+#ifdef __GNUC__
+  while (!__atomic_compare_exchange_n(l, &old, 1, 1, __ATOMIC_ACQUIRE,
+#endif
+
+#ifdef __clang__
   while (!__c11_atomic_compare_exchange_weak(l, &old, 1, __ATOMIC_ACQUIRE,
+#endif
         __ATOMIC_RELAXED))
     old = 0;
 }
-- 
2.34.1
